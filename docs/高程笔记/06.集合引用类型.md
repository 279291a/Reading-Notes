## `Object`类型

创建方式（2 种）：

1. 使用`new`操作符后跟`Object`构造函数

   ```js
   var person = new Object();
   ```

2. 对象字面量表示，推荐使用方式

   ```javascript
   var perosn = {
     name: "me",
   };
   ```

访问属性（2 种）：`点表示法`和`[]表示法`，后者的优点是可以通过变量来访问属性。通常使用点表示法来进行访问。

## `Array` 类型

`ECMASCript`数组与其他语言的**不同**：

1. 每一项都可以保存**任何类型**的值
2. 可以动态调整数组大小

### **创建**

- 使用`Array`构造函数，可以省略`new`操作符
  - 传递数组长度
  - 传递数组中的项
  - 传递一个值，如果是数字，则创建给定长度的数组，如果是其他类型的参数，则创建包含那个值长度为 1 的数组。
- 数组字面量表示
- `Array.from` 将类数组转化为数组对象
- `Array.of()` 将传入的参数转换为数组

### 空位

- 使用数组字面量初始化数组时，使用一连串逗号来创建空位
- 显式使用 `undefined` 创建空位

### 读取和设置

- 使用`[]`并通过数字索引，比如

  ```js
  var nums = [1, 2, 3, 4];
  nums[0]; // 1
  ```

- 同样使用 `[]` 及数字索引来设置

### **`length`属性**

- `length`属性保存数组的长度，**可读可写**。可以通过修改该属性来设置数组长度。
- **通常用途：**通过设置`length`可以从数组的末尾移除项或向数组中添加新项。

### **检测数组**

- `ES5`提出了`Array.isArray()`方法
- 在一个全局作用域下可以使用`instanceof`

### 迭代器方法

- `keys()` 返回数组索引
- `values()` 返回数组元素
- `entries()` 返回键值对

### 复制和填充

- `fill()` 填充数组方法，向已有的数组中插入全部或部分的值。
- `copyWithin()` 复制数组中的部分内容，将其插入到指定开始的位置

### 转换方法

- `valueOf()` 返回数组本身

- `toString()` 调用每个元素的 `toString()` 方法，最终返回一个逗号分隔的字符串。
- `toLocalString()` 调用每个元素的 `toLocalString()` 方法，最终返回一个逗号分隔的字符串。
- `join()` 使用指定的分隔符将数组中的元素连接起来，返回连接后的字符串

### 栈方法

`栈`是一种**后进先出**的数据结构，栈中项的推入和弹出都发生在栈的顶部。

- `push()`：接收任意数量的参数，把它们逐个添加到元素末尾，并返回修改后数组的长度。
- `pop()`：从数组的末位移除最后一项，并返回并移除的元素。

### 队列方法

**_队列_** **先进先出**的数据结构。在列表的**末位添加**项，从列表的**开头移除**项。
使用`push()`和`shift()`可以模拟队列先进先出，使用`unshift()`和`pop()` 可以反向模拟队列，也就是在数组开头添加数据，在数据末尾取得数据。

- `shift()`:移除数组的第一项并返回该元素。
- `unshift()`:在数组的前端添加任意个项并返回新元素长度。

### 排序

下列这两个排序方法都对原数组进行修改

- `reverse()`：将数组反向排列
- `sort()`:将数组元素进行排序，默认调用调用 `String()`转型将每个数组元素转换为字符型，然后根据字符串比较来决定顺序。接收比较函数，根据比较函数的结构排序。

### 操作方法

- `concat()` 将接受到的参数添加到数组的末尾，并返回新数组。如果参数是数组，就会将数组中的每一项添加到结果数组中。

- `slice()` 基于接收的开始索引和结束索引，使用当前数组创建一个新数组。如果参数是负数，则加上数组长度以确定位置。
- `splice()`主要是向数组中插入项，参数为（起始位置，删除个数，替换项）。该方法在原数组上进行修改。
  - 删除：只传入前两个参数
  - 插入：提供三个参数：起始位置，0，和插入项
  - 替换：提供三个参数：起始位置，删除个数 和 插入项

### 位置方法

- 按照严格相等查找
  - `indexOf(item,startIndex)`：从数组的开头查找指定项的位置，找不到则返回 -1 。
  - `lastIndexOf(searchItem, startIndex)`：从数组的末尾查找指定项的位置，找不到则返回 -1 。
  - `includes(searchString, startIndex)` 从指定的开始位置查找指定项，返回是否查找到的布尔值。
- 按照断言函数返回结果查找
  - `find((element,index,array) => {})` 返回第一个匹配的元素
  - `findIndex((element,index,array) => {})` 返回第一个匹配元素的索引

### 迭代

ECMAScript 定义了 5 个迭代方法，每个方法均接受两个参数，要在每一项上运行的函数和运行该函数的作用域。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。

- `every()` 查询每项是否都满足条件，返回布尔值。
- `filter()` 返回符合条件的所有数组项，如果传入返回 `true`,则符合条件。
- `forEach()` 对每项都运行给定函数，没有返回值。可以替代`for`
- `map()` 对每项都运行给定函数，返回一个与原数组一一对应的数组。
- `some()`查询数组中是否有满足给定函数的项，如果有一项对函数返回`true`,则返回`true` 。

### 归并

ECMAScript 提供了两个归并方法，用于迭代数组所有项，再此基础上构建一个最终返回值。

归并方法接收一个归并函数和初始值，归并函数接收：上一个归并值，当前值，当前项索引和数组本身。

- `reduce()`：从数组第一项开始迭代，返回一个归并值。
- `reduceRight()`：从数组最后一项开始迭代，返回一个归并值。

## 定型数组

JavaScript 实际上并没有定型数组，它指的是一种特殊的包含数值类型的数组。目的是为了提升项原生库传输数据的效率。主要是用于绘图方面。

### ArrayBuffer

- `ArrayBuffer` 用于在内存中分配特定数量的字节空间。有点像是 C 语言中的 `malloc()` 函数

  ```js
  const buff = new ArrayBuffer(16);
  console.log(buff.byteLength);
  ```

- `ArrayBuffer` 一经创建就不能更改大小，但是可以通过 `slice()` 来复制。

- `ArrayBuffer` 不能通过对对象的引用来进行读写，必须通过视图来读写。

### DataView

> 第一种允许读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。

#### 创建

必须在对已有的 `ArrayBuffer` 实例进行读写时才能创建 `DataView` 实例。

```js
const buff = new ArrayBuffer(16);
const dv = new DataView(buff);
```

#### 实例属性

- `byteOffset` 字节偏移量
- `byteLength` 字节长度
- `buffer` 指向创建视图实例时的 ArrayBuffer 实例。

#### ElementType

> DateView 要使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。ECMAScript 6 中支持 8 中不同的 ElmentType。DataView 为这 8 种类型暴露了 `get` 和 `set` 方法

| ElementType | 字节 |
| ----------- | ---- |
| Int8        | 1    |
| Unit8       | 1    |
| Int16       | 2    |
| Unit16      | 2    |
| Int32       | 4    |
| Unit32      | 4    |
| Float32     | 4    |
| Float64     | 8    |

#### 字节序

> **_字节序_** 指的是计算机维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。

#### 边界情形

- 读写操作如果没有足够的缓冲区，就会抛出 RangerError。
- 写入操作会将一个值转换为适当的类型，后备为 0，如果无法转换，则抛出错误。
